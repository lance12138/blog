---
title: java中如何正确使用volatile
date: 2017-04-16 15:23:15
tags: volatile,多线程
---

![雷州岛][1]
### 引言
对于java开发同学来说，说到多线程首先想到的就是队列、synchronized、lock等等，就这几个东西就够说好几个文章的篇幅了，今天我们主角并不是它们，而是并不太受欢迎的volatile。很多开发同学可能一碰到多线程变量共享问题直接上锁，当然这样做也是无可以厚非，毕竟木有用错，只能说这样编码不是那么的优雅，如果说能使用锁和volatile配合使用无论对性能也好还是对java语言的理解也都是很有帮助的。
<!--more-->
volatile关键字在java多线程中有着比较重要作用，volatile主要作用是可以保持变量在多线程中是实时可见的,是java中提供的最轻量的同步机制。

### 可见性
在Java的内存模型中所有的的变量（这里的变量是类全局变量，并不是局部变量，局部变量在方法内并没有线程安全的问题，因为变量随方法调用完成而销毁）都是存放在主内存中的，而每个线程有自己的工作内存，每次线程执行时，会从主内存获取变量的拷贝，对变量的操作都在线程的工作内存中进行，不同线程之间也不能共享工作内存，只能从主内存读取变量的拷贝。具体可以通过下图来表示：
![jvm线程内存模型][2]

然而对于volatile（使用synchronized/final修饰都具有可见性）来说打破了上述的规则，即当线程修改了变量的值，其他线程可以立即知道该变量的改变。然而对于普通变量来说，当一个线程修改了变量，需要先将变量写回主内存，其他线程从主内存读取变量后才对该线程可见。似乎从以上的描述可以推导出只要使用volatile修饰的变量就可以保证该变量在多线程环境下操作是安全的，因为它对于所有线程的工作内存都是可见的也就是说一致的。这么理解确实没错，但是在java中很多运算都不是原子的，所以在java的一些运算中使用volatile并不能保证线程安全问题。让我们来看一个例子：
```
public class test{
private static volatile t=0;
   private static int add(){
        return t++;
    }

    public static void testVolatile(){
        for (int i=0;i<20;i++){
            Thread thread=new Thread(()-> {
                for (int j=0;j<1000;j++) {
                    add();
                }
            });
            thread.start();
        }
        while (Thread.activeCount()>1){
            Thread.yield();
        }
        System.out.println(t);
    }
    
    public static void main(String[] args){
        testVolatile();
    }
}
```
预期这个t值应该是20000，但是会出现t值小于20000的情况，原因大家应该猜到了，问题出在t++上，t++并不是一个原子操作，t++的操作在java中代表先获取t值，再加1，再赋值还t。在获取t值时因为是volatile修饰的，所以可以获取线程最新值，然而在加1的时候就不能保证了，有可能其他线程已经加1了。
### 使用场景
那么什么场景使用volatile是最合适的呢？
* 在变量运算不依赖当前值
* 变量不需要与其他状态变量共同参与不变约束
翻译成中文就是对于那些在**多线程中既有读又有写的变量，完全可以使用volatile修饰**，这样就对于读操作就不要使用lock/synchronized比较重的操作了，直接读就是，因为变量是可见的。


  [1]: /images/雷州岛.jpg "雷州岛"
  [2]: /images/jvm线程内存模型.png "jvm线程内存模型"